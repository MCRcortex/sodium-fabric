#version 460 core

#import <sodium:cull/datatypes.h>

//FIXME: optimize local_size and add restrict to all bindings that can use it
layout(local_size_x = 16) in;

layout(std430, binding = 0) restrict readonly buffer SceneData {
    mat4 mat_modelviewproj;
    Vec3F negativeCameraPosRegionRelative;
    uint max_translucency;
};

//readonly
layout(std430, binding = 1) restrict readonly buffer MetaData {
    SectionMeta sections[];
};
#define SECTION sections[gl_GlobalInvocationID.x]

layout(std430, binding = 2) restrict buffer VisibilityBuffer {
    uint visiblity[];
};

layout(std430, binding = 3) restrict writeonly buffer SectionCPUVisibilityBuffer {
    uint CPUvisiblity[];
};

layout(std430, binding = 4) restrict buffer CounterBuffer {
    uint instanceCounter;
    uint cmdBuff0Count;
    uint cmdBuff1Count;
    uint cmdBuff2Count;
    uint count3;
};

layout(std430, binding = 5) restrict writeonly buffer InstanceDataBuffer {
    InstanceData instances[];
};

layout(std430, binding = 6) restrict writeonly buffer Id2InstanceDataBuffer {
    uint id2Inst[];
};

layout(std430, binding = 7) restrict writeonly buffer CommandBuffer0 {
    DrawElementsInstancedCommand cmdBuff0[];
};

layout(std430, binding = 8) restrict writeonly buffer CommandBuffer1 {
    DrawElementsInstancedCommand cmdBuff1[];
};

layout(std430, binding = 9) restrict writeonly buffer CommandBuffer2 {
    DrawElementsInstancedCommand cmdBuff2[];
};


layout(std430, binding = 10) restrict buffer TransSorted {
    uint translucency[];
};

void bubbleInsertTranslucency(uint zcur, uint index) {
    uint i = 0;
    //TODO: try finetune to this to closer upper bound like 1.5 or 1.75
    uint test = index/2;
    if (translucency[test]<=zcur) {
        i = test;
    }
    //TODO: as much presorting/locating as possible
    for (; i < max_translucency; i++) {
        uint ztest = atomicMin(translucency[i], zcur);
        if(ztest == 0xFFFFFFFF)
        {
            break;
        }
        zcur = (ztest > zcur) ? ztest : zcur;
    }
}

void main() {
    if (SECTION.id != gl_GlobalInvocationID.x) return;
    if (visiblity[gl_GlobalInvocationID.x] == 0) {
        CPUvisiblity[gl_GlobalInvocationID.x] = 0;
        return;
    }
    CPUvisiblity[gl_GlobalInvocationID.x] = 1;
    visiblity[gl_GlobalInvocationID.x] = 0;

    //TODO: cant i technically just remove hsize and it would have the same effect kinda? would be comparing 0 and bboxSize instead
    vec3 hsize = Vec3FtoVec3(SECTION.bboxSize)/2;
    vec3 center = Vec3FtoVec3(SECTION.bboxOffset) + hsize + Vec3FtoVec3(negativeCameraPosRegionRelative);

    uint vismsk = 64;
    vismsk |= center.y<hsize.y ?  1 : 0;
    vismsk |= center.y>-hsize.y?  2 : 0;
    vismsk |= center.x<hsize.x ?  4 : 0;
    vismsk |= center.x>-hsize.x?  8 : 0;
    vismsk |= center.z<hsize.z ? 16 : 0;
    vismsk |= center.z>-hsize.z? 32 : 0;
    //Replicate vismsk to fill the full 4 bytes with the same mask, this is to easily mask all 4 layers in 1 operation
    vismsk |= vismsk<<8;
    vismsk |= vismsk<<16;

    {
        //msk is the visibility mask of all the layers, 1 byte per layer
        uint msk = SECTION.lvis & vismsk;
        //If there is no visible face visible, just return, no need to continue
        if (msk == 0)
            return;

        uint instanceId = atomicAdd(instanceCounter, 1);
        //FIXME: MAKE FASTER or move to camera transform matrix inside terrain render
        vec3 cm = Vec3FtoVec3(negativeCameraPosRegionRelative);
        vec3 ps = Vec3FtoVec3(SECTION.pos);
        instances[instanceId].pos = Vec3toVec3F(ps+cm);//FIXME: Need to compute relative to camera

        //Atomicly compute and increment the index of the start of the grouped commands, this is done as so only 1
        // atomic operation is needed per layer
        /*
        uint cmd0Idx = (msk&255)==0?0:atomicAdd(cmdBuff0Count, bitCount(msk&255));
        uint cmd1Idx = (msk&(255<<8))==0?0:atomicAdd(cmdBuff1Count, bitCount(msk&(255<<8)));
        uint cmd2Idx = (msk&(255<<16))==0?0:atomicAdd(cmdBuff2Count, bitCount(msk&(255<<16)));
        //uint cmd3Idx = (msk&(255<<24))==0?0:atomicAdd(cmdBuff3Count, bitCount(msk&(255<<24)));
        //barrier();
        */
        uint cmd0Idx = atomicAdd(cmdBuff0Count, bitCount(msk & 255));
        uint cmd1Idx = atomicAdd(cmdBuff1Count, bitCount(msk & (255<<8)));
        uint cmd2Idx = atomicAdd(cmdBuff2Count, bitCount(msk & (255<<16)));


        //Skip msk is each layers mask ored together, this is used to acclerate checks in the main command gen loop
        uint skipmsk = msk|(msk>>16);
        skipmsk |= skipmsk>>8;
        skipmsk &= 255;

        //All remaining work groups should be in the same "warp state" up to this loop
        // past this loop the work groups start to diverge, which is bad for performance but not much
        // can be done to fix this only reduce the amount of time its spent in this loop

        //TODO: try unrolling this loop, any if false, should just be written to a dummy command index
        for (uint i = 0; skipmsk != 0; i++, skipmsk >>= 1) {
            // if no layer has a face for this side, skip
            if ((skipmsk&1) == 0) continue;
            //FIXME: prefill the cmdBuff with instanceCount = 1 and firstIndex = 0 as having them constantly be set
            // to the same thing each time is a huge waste of bandwidth

            //i is the current "batch/side"
            if ((msk&((1)<<i)) != 0) {//Layer 0
                cmdBuff0[cmd0Idx].count = SECTION.SOLID[i].count;
                cmdBuff0[cmd0Idx].instanceCount = 1;
                cmdBuff0[cmd0Idx].firstIndex = 0;
                cmdBuff0[cmd0Idx].baseVertex = SECTION.SOLID[i].offset;
                cmdBuff0[cmd0Idx].baseInstance = instanceId;
                cmd0Idx++;
            }

            if ((msk&((1<<8)<<i)) != 0) {//Layer 1
                cmdBuff1[cmd1Idx].count = SECTION.CUTOUT_MIPPED[i].count;
                cmdBuff1[cmd1Idx].instanceCount = 1;
                cmdBuff1[cmd1Idx].firstIndex = 0;
                cmdBuff1[cmd1Idx].baseVertex = SECTION.CUTOUT_MIPPED[i].offset;
                cmdBuff1[cmd1Idx].baseInstance = instanceId;
                cmd1Idx++;
            }

            if ((msk&((1<<16)<<i)) != 0) {//Layer 2
                cmdBuff2[cmd2Idx].count = SECTION.CUTOUT[i].count;
                cmdBuff2[cmd2Idx].instanceCount = 1;
                cmdBuff2[cmd2Idx].firstIndex = 0;
                cmdBuff2[cmd2Idx].baseVertex = SECTION.CUTOUT[i].offset;
                cmdBuff2[cmd2Idx].baseInstance = instanceId;
                cmd2Idx++;
            }
            /*
            if ((msk&((1<<24)<<i)) != 0) {//Layer 3
                cmdBuff3[cmd3Idx].count = SECTION.TRANSLUCENT[i].count;
                cmdBuff3[cmd3Idx].instanceCount = 1;
                cmdBuff3[cmd3Idx].firstIndex = 0;
                cmdBuff3[cmd3Idx].baseVertex = SECTION.TRANSLUCENT[i].offset;
                cmdBuff3[cmd3Idx].baseInstance = instanceId;
                cmd3Idx++;
            }*/
        }

        {
            //Insert translucency if it is visible
            if (((msk&(255<<24))!=0)) {
                if (max_translucency != 0) {
                    uint index = atomicAdd(count3, 1);
                    id2Inst[SECTION.id] = instanceId;
                    uint distance = 1-uint(sqrt(dot(center, center)));//the 1- is to invert it to reverse sort
                    //Leave 12 bits for id which should be more than enough given a region size of 16x16x16
                    uint sortKey = (distance<<12)|SECTION.id;
                    bubbleInsertTranslucency(sortKey, index);
                }
            }
        }
    }
}