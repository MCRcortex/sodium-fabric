#version 460 core

#import <sodium:cull/datatypes.h>

//FIXME: optimize local_size and add restrict to all bindings that can use it
layout(local_size_x = 16) in;

layout(std430, binding = 0) restrict readonly buffer SceneData {
    mat4 mat_modelviewproj;
    Vec3F negativeCameraPosRegionRelative;
    uint max_translucency;
};

//readonly
layout(std430, binding = 1) restrict readonly buffer MetaData {
    SectionMeta sections[];
};
#define SECTION sections[gl_GlobalInvocationID.x]

layout(std430, binding = 2) restrict buffer VisibilityBuffer {
    uint visiblity[];
};

layout(std430, binding = 3) restrict writeonly buffer SectionCPUVisibilityBuffer {
    uint CPUvisiblity[];
};

layout(std430, binding = 4) restrict buffer CounterBuffer {
    uint instanceCounter;
    uint cmdBuff0Count;
    uint cmdBuff1Count;
    uint cmdBuff2Count;
    uint count3;
};

layout(std430, binding = 5) restrict writeonly buffer InstanceDataBuffer {
    InstanceData instances[];
};

layout(std430, binding = 6) restrict writeonly buffer Id2InstanceDataBuffer {
    uint id2Inst[];
};

layout(std430, binding = 7) restrict writeonly buffer CommandBuffer0 {
    DrawElementsInstancedCommand cmdBuff0[];
};

layout(std430, binding = 8) restrict writeonly buffer CommandBuffer1 {
    DrawElementsInstancedCommand cmdBuff1[];
};

layout(std430, binding = 9) restrict writeonly buffer CommandBuffer2 {
    DrawElementsInstancedCommand cmdBuff2[];
};


layout(std430, binding = 10) restrict buffer TransSorted {
    uint translucency[];
};

void bubbleInsertTranslucency(uint zcur, uint index) {
    uint i = 0;
    //TODO: try finetune to this to closer upper bound like 1.5 or 1.75
    uint test = index/2;
    if (translucency[test]<=zcur) {
        i = test;
    }
    //TODO: as much presorting/locating as possible
    for (; i < max_translucency; i++) {
        uint ztest = atomicMin(translucency[i], zcur);
        if(ztest == 0xFFFFFFFF)
        {
            break;
        }
        zcur = (ztest > zcur) ? ztest : zcur;
    }
}
uint cmd0Idx;
uint cmd1Idx;
uint cmd2Idx;
uint msk;
uint instanceId;
//TODO: try an out of bounds idx
/*
#define VOID_IDX 4095
void innerdo(uint i) {
    uint idxx = ((msk&((1)<<i)) != 0)?cmd0Idx:VOID_IDX;
    cmdBuff0[idxx].count = SECTION.SOLID[i].count;
    cmdBuff0[idxx].instanceCount = 1;
    cmdBuff0[idxx].firstIndex = 0;
    cmdBuff0[idxx].baseVertex = SECTION.SOLID[i].offset;
    cmdBuff0[idxx].baseInstance = instanceId;
    cmd0Idx+=uint(((msk&((1)<<i)) != 0));

    idxx = ((msk&((1<<8)<<i)) != 0)?cmd1Idx:VOID_IDX;
    cmdBuff1[idxx].count = SECTION.CUTOUT_MIPPED[i].count;
    cmdBuff1[idxx].instanceCount = 1;
    cmdBuff1[idxx].firstIndex = 0;
    cmdBuff1[idxx].baseVertex = SECTION.CUTOUT_MIPPED[i].offset;
    cmdBuff1[idxx].baseInstance = instanceId;
    cmd1Idx+=uint(((msk&((1<<8)<<i)) != 0));

    idxx = ((msk&((1<<16)<<i)) != 0)?cmd2Idx:VOID_IDX;
    cmdBuff2[idxx].count = SECTION.CUTOUT[i].count;
    cmdBuff2[idxx].instanceCount = 1;
    cmdBuff2[idxx].firstIndex = 0;
    cmdBuff2[idxx].baseVertex = SECTION.CUTOUT[i].offset;
    cmdBuff2[idxx].baseInstance = instanceId;
    cmd2Idx+=uint(((msk&((1<<16)<<i)) != 0));
}*/


void main() {
    //Ordered this way to heavily reduce memory loads
    if (visiblity[gl_GlobalInvocationID.x] == 0) {
        //FIXME: THIS MAKES IT SLOW DOWN BY QUITE A BIT, probably cause of all the access's to cpu memory
        //CPUvisiblity[gl_GlobalInvocationID.x] = 0;
        return;
    }
    //visiblity[gl_GlobalInvocationID.x] = 0;
    if (SECTION.id != gl_GlobalInvocationID.x) return;
    //const SectionMeta LOCAL_SECTION = sections[gl_GlobalInvocationID.x];
    //TODO: cant i technically just remove hsize and it would have the same effect kinda? would be comparing 0 and bboxSize instead
    vec3 hsize = Vec3FtoVec3(SECTION.bboxSize)/2;
    vec3 center = Vec3FtoVec3(SECTION.bboxOffset) + hsize + Vec3FtoVec3(negativeCameraPosRegionRelative);
    //TODO: move this to the raster_depth_test.vert shader, maybe using the depth buffer
    if ((center.x*center.x + center.z*center.z)>(32*32*16*16)) {
        //CPUvisiblity[gl_GlobalInvocationID.x] = 0;
        return;
    }
    //TODO: also try do exact face culling like in jellys pr
    // might be slower but would heavily reduce overdraw probably
    msk = SECTION.lvis;
    msk &= center.y<hsize.y ? 0xFFFFFFFF : 4278124286;
    msk &= center.y>-hsize.y? 0xFFFFFFFF : 4261281277;
    msk &= center.x<hsize.x ? 0xFFFFFFFF : 4227595259;
    msk &= center.x>-hsize.x? 0xFFFFFFFF : 4160223223;
    msk &= center.z<hsize.z ? 0xFFFFFFFF : 4025479151;
    msk &= center.z>-hsize.z? 0xFFFFFFFF : 3755991007;
    /*
    uint vismsk = 64;
    vismsk |= center.y<hsize.y ?  1 : 0;
    vismsk |= center.y>-hsize.y?  2 : 0;
    vismsk |= center.x<hsize.x ?  4 : 0;
    vismsk |= center.x>-hsize.x?  8 : 0;
    vismsk |= center.z<hsize.z ? 16 : 0;
    vismsk |= center.z>-hsize.z? 32 : 0;
    //Replicate vismsk to fill the full 4 bytes with the same mask, this is to easily mask all 4 layers in 1 operation
    vismsk |= vismsk<<8;
    vismsk |= vismsk<<16;
    msk &= vismsk;*/
    {
        //msk is the visibility mask of all the layers, 1 byte per layer
        //If there is no visible face visible, just return, no need to continue
        if (msk == 0) {
            //CPUvisiblity[gl_GlobalInvocationID.x] = 0;
            return;
        }
        CPUvisiblity[gl_GlobalInvocationID.x] = 1;

        instanceId = atomicAdd(instanceCounter, 1);
        //FIXME: MAKE FASTER or move to camera transform matrix inside terrain render
        vec3 cm = Vec3FtoVec3(negativeCameraPosRegionRelative);
        vec3 ps = Vec3FtoVec3(SECTION.pos);
        instances[instanceId].pos = Vec3toVec3F(ps+cm);//FIXME: Need to compute relative to camera

        //Atomicly compute and increment the index of the start of the grouped commands, this is done as so only 1
        // atomic operation is needed per layer
        /*
        uint cmd0Idx = (msk&255)==0?0:atomicAdd(cmdBuff0Count, bitCount(msk&255));
        uint cmd1Idx = (msk&(255<<8))==0?0:atomicAdd(cmdBuff1Count, bitCount(msk&(255<<8)));
        uint cmd2Idx = (msk&(255<<16))==0?0:atomicAdd(cmdBuff2Count, bitCount(msk&(255<<16)));
        //uint cmd3Idx = (msk&(255<<24))==0?0:atomicAdd(cmdBuff3Count, bitCount(msk&(255<<24)));
        //barrier();
        */


        //cmd0Idx = atomicAdd(cmdBuff0Count, bitCount(msk & 255));
        //cmd1Idx = atomicAdd(cmdBuff1Count, bitCount(msk & (255<<8)));
        //cmd2Idx = atomicAdd(cmdBuff2Count, bitCount(msk & (255<<16)));


        //Skip msk is each layers mask ored together, this is used to acclerate checks in the main command gen loop
        uint skipmsk = msk|(msk>>16);
        skipmsk |= skipmsk>>8;
        skipmsk &= 255;

        //All remaining work groups should be in the same "warp state" up to this loop
        // past this loop the work groups start to diverge, which is bad for performance but not much
        // can be done to fix this only reduce the amount of time its spent in this loop
        for (uint i = 0; skipmsk != 0; i++, skipmsk >>= 1) {
            // if no layer has a face for this side, skip
            if ((skipmsk&1) == 0) continue;
            if ((msk&((1)<<i)) != 0) {//Layer 0
                cmd0Idx = atomicAdd(cmdBuff0Count, 1);
                cmdBuff0[cmd0Idx].count = SECTION.SOLID[i].count;
                cmdBuff0[cmd0Idx].baseVertex = SECTION.SOLID[i].offset;
                cmdBuff0[cmd0Idx].baseInstance = instanceId;
                //cmd0Idx++;
            }

            if ((msk&((1<<8)<<i)) != 0) {//Layer 1
                cmd1Idx = atomicAdd(cmdBuff1Count, 1);
                cmdBuff1[cmd1Idx].count = SECTION.CUTOUT_MIPPED[i].count;
                cmdBuff1[cmd1Idx].baseVertex = SECTION.CUTOUT_MIPPED[i].offset;
                cmdBuff1[cmd1Idx].baseInstance = instanceId;
                //cmd1Idx++;
            }

            if ((msk&((1<<16)<<i)) != 0) {//Layer 2
                cmd2Idx = atomicAdd(cmdBuff2Count, 1);
                cmdBuff2[cmd2Idx].count = SECTION.CUTOUT[i].count;
                cmdBuff2[cmd2Idx].baseVertex = SECTION.CUTOUT[i].offset;
                cmdBuff2[cmd2Idx].baseInstance = instanceId;
                //cmd2Idx++;
            }
        }

        {
            //Insert translucency if it is visible
            if ((max_translucency != 0) && ((msk&(255<<24))!=0)) {
                uint index = atomicAdd(count3, 1);
                id2Inst[SECTION.id] = instanceId;
                uint distance = 1-uint(sqrt(dot(center, center)));//the 1- is to invert it to reverse sort
                //Leave 12 bits for id which should be more than enough given a region size of 16x16x16
                uint sortKey = (distance<<12)|SECTION.id;
                bubbleInsertTranslucency(sortKey, index);
            }
        }
    }
}